
namespace exploits {
	namespace psilent {
		namespace g {
			engine::fvector silent_location;
		}

		double* ( *update_damage_start_location_original )( engine::a_fort_weapon*, double*, double* );
		double* update_damage_start_location( engine::a_fort_weapon* current_weapon, double* start_location, double* angles ) {
			auto silent_location = g::silent_location;
			if ( features::exploits::silent_aim && silent_location ) {
				angles[ 0 ] = silent_location.m_x - start_location[ 0 ];
				angles[ 1 ] = silent_location.m_y - start_location[ 1 ];
				angles[ 2 ] = silent_location.m_z - start_location[ 2 ];
			}

			return update_damage_start_location_original( current_weapon, start_location, angles );
		}

		bool apply( engine::a_fort_weapon* weapon ) {
			static vmt::c_vmt vmt;
			if ( !vmt.setup( weapon, offsets::update_damage_start_location ) )
				return false;

			auto is_hooked = vmt.is_hooked_function(
				offsets::update_damage_start_location,
				update_damage_start_location
			);
			if ( is_hooked )
				return true;

			auto result = vmt.create_hook(
				update_damage_start_location,
				&update_damage_start_location_original
			);
			if ( !result )
				return false;

			return vmt.is_hooked_function(
				offsets::update_damage_start_location,
				update_damage_start_location
			);
		}
	}
}