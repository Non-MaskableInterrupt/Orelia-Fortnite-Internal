
namespace exploits {
    class c_desync {
    public:
        struct movement_state {
            float original_walk_speed;
            float original_fly_speed;
            float original_custom_speed;
            float original_gravity;
            float original_acceleration;
            float original_friction_factor;
            float original_ground_friction;
            float original_jump_velocity;
            float original_jump_factor;
            float original_air_control;
            float original_air_boost;
            float original_lateral_friction;
            bool original_rotation_to_movement;
            bool original_flying;
            uint8_t original_movement_mode;
            float original_buoyancy;
            bool original_disable_movement;
            float original_max_step_height;
            bool original_movement_in_progress;
            bool original_enable_physics_interaction;
        };

        struct pawn_state {
            engine::e_net_role original_role;
            engine::e_net_role original_remote_role;
            engine::e_net_dormancy original_dormancy;
            bool original_always_relevant;
            bool original_replicates;
            bool original_replicate_movement;
        };

    public:
        void apply( engine::a_pawn* local_pawn ) {
            if ( features::exploits::desync ) {
                enable( local_pawn );

                if ( features::exploits::player_fly ) {
                    if ( !m_is_flying ) {
                        enable_fly( local_pawn );
                    }
                }
                else if ( m_is_flying ) {
                    disable_fly( local_pawn );
                }

                toggle_noclip( local_pawn, features::exploits::no_clip );
                toggle_bhop( local_pawn, features::exploits::bhop );
                toggle_super_jump( local_pawn, features::exploits::super_jump );
                toggle_slide_mode( local_pawn, features::exploits::super_slide );
            }
            else {
                if ( m_is_flying ) {
                    disable_fly( local_pawn );
                }
                disable( local_pawn );
            }
        }

        void force_network_update( engine::a_pawn* local_pawn ) {
            if ( !local_pawn || !m_is_enabled )
                return;

            local_pawn->force_net_update( );
            local_pawn->flush_net_dormancy( );
        }

        void enable_fly( engine::a_pawn* local_pawn ) {
            if ( !local_pawn || !m_is_enabled )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                if ( !m_is_flying ) {
                    m_original_movement_state.original_movement_mode = movement->movement_mode( );
                }

                movement->movement_mode( 2 );

                movement->max_fly_speed( 2000.f );
                movement->max_acceleration( 4000.f ); // Reduced for stability
                movement->braking_friction_factor( 0.1f ); // Small amount for better control
                movement->gravity_scale( 0.f );

                // Improved air control
                movement->air_control( 1.f );
                movement->air_control_boost_multiplier( 2.f );
                movement->falling_lateral_friction( 0.1f );

                movement->b_maintain_horizontal_ground_velocity( true );
                movement->b_impart_base_velocity_x( true );
                movement->b_impart_base_velocity_y( true );
                movement->b_impart_base_velocity_z( true );

                movement->max_step_height( 0.f );
                movement->b_movement_in_progress( true );
                movement->b_orient_rotation_to_movement( true );

                movement->b_update_on_only_if_rendered( true );
                movement->b_auto_update_tick_registration( true );
                movement->b_tick_before_owner( true );

                m_is_flying = true;
            }
        }

        void disable_fly( engine::a_pawn* local_pawn ) {
            if ( !local_pawn || !m_is_flying )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                movement->set_movement_mode( m_original_movement_state.original_movement_mode );

                movement->max_fly_speed( m_original_movement_state.original_fly_speed );
                movement->gravity_scale( m_original_movement_state.original_gravity );
                movement->max_step_height( m_original_movement_state.original_max_step_height );
                movement->b_movement_in_progress( m_original_movement_state.original_movement_in_progress );

                m_is_flying = false;
            }
        }

        void set_fly_speed( engine::a_pawn* local_pawn, float speed ) const {
            if ( !local_pawn || !m_is_flying )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                movement->max_fly_speed( speed );
                movement->set_max_fly_speed( speed );
            }
        }

        void set_fly_gravity( engine::a_pawn* local_pawn, float gravity ) const {
            if ( !local_pawn || !m_is_flying )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                movement->gravity_scale( gravity );
                movement->set_gravity_scale( gravity );
            }
        }

        void toggle_noclip( engine::a_pawn* local_pawn, bool enable ) const {
            if ( !local_pawn || !m_is_flying )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                movement->b_enable_physics_interaction( !enable );
                if ( enable ) {
                    movement->max_step_height( 0.f );
                    movement->ground_friction( 0.f );
                    movement->braking_friction_factor( 0.f );
                }
                else {
                    movement->max_step_height( m_original_movement_state.original_max_step_height );
                    movement->ground_friction( m_original_movement_state.original_ground_friction );
                    movement->braking_friction_factor( m_original_movement_state.original_friction_factor );
                }
            }
        }

        void toggle_slide_mode( engine::a_pawn* local_pawn, bool enable ) const {
            if ( !local_pawn || !m_is_enabled )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                if ( enable ) {
                    movement->ground_friction( 0.f );
                    movement->braking_friction_factor( 0.f );
                    movement->falling_lateral_friction( 0.f );
                }
                else {
                    movement->ground_friction( m_original_movement_state.original_ground_friction );
                    movement->braking_friction_factor( m_original_movement_state.original_friction_factor );
                    movement->falling_lateral_friction( m_original_movement_state.original_lateral_friction );
                }
            }
        }

        void toggle_bhop( engine::a_pawn* local_pawn, bool enable ) const {
            if ( !local_pawn || !m_is_enabled )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                if ( enable && movement->is_falling( ) ) {
                    movement->jump_z_velocity( 600.f );
                    movement->b_notify_apex_when_fall_height_reached( false );
                }
            }
        }

        void toggle_super_jump( engine::a_pawn* local_pawn, bool enable ) const {
            if ( !local_pawn || !m_is_enabled )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                if ( enable ) {
                    movement->jump_z_velocity( 1200.f );
                    movement->jump_off_jump_z_factor( 2.f );
                }
                else {
                    movement->jump_z_velocity( m_original_movement_state.original_jump_velocity );
                    movement->jump_off_jump_z_factor( m_original_movement_state.original_jump_factor );
                }
            }
        }

        void handle_movement_validation( engine::a_pawn* local_pawn ) const {
            if ( !local_pawn || !m_is_enabled )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                movement->b_maintain_horizontal_ground_velocity( true );
                movement->b_impart_base_velocity_x( true );
                movement->b_impart_base_velocity_y( true );
                movement->b_impart_base_velocity_z( true );
                movement->b_impart_base_angular_velocity( true );

                movement->analog_input_modifier( 1.0f );
                movement->b_requested_move_use_acceleration( true );

                movement->b_ignore_client_movement_error_checks_and_correction( true );
                movement->b_server_accept_client_authoritative_position( true );

                //movement->network_max_smooth_update_distance( 0.f );
                //movement->network_no_smooth_update_distance( 0.f );
                //movement->network_simulated_smooth_location_time( 0.f );
                //movement->network_simulated_smooth_rotation_time( 0.f );
            }
        }

        void update_fly_controls( engine::a_player_controller* player_controller, engine::a_pawn* local_pawn ) const {
            if ( !local_pawn || !m_is_flying )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                engine::fvector input_vector{ 0.f, 0.f, 0.f };

                if ( player_controller->is_input_key_down( engine::keys::g_spacebar ) ) {
                    input_vector.m_z += 1.f;
                }
                if ( player_controller->is_input_key_down( engine::keys::g_left_shift ) ) {
                    input_vector.m_z -= 1.f;
                }

                if ( player_controller->is_input_key_down( engine::keys::g_w ) ) {
                    input_vector.m_x += 1.f;
                }
                if ( player_controller->is_input_key_down( engine::keys::g_s ) ) {
                    input_vector.m_x -= 1.f;
                }

                if ( player_controller->is_input_key_down( engine::keys::g_a ) ) {
                    input_vector.m_y -= 1.f;
                }
                if ( player_controller->is_input_key_down( engine::keys::g_d ) ) {
                    input_vector.m_y += 1.f;
                }

                movement->add_input_vector( input_vector.normalize( ) );
            }
        }

        void enable( engine::a_pawn* local_pawn ) {
            if ( !local_pawn )
                return;

            save_pawn_state( local_pawn );

            local_pawn->role( engine::e_net_role::e_net_role_autonomous_proxy );
            local_pawn->remote_role( engine::e_net_role::e_net_role_autonomous_proxy );
            local_pawn->net_dormancy( engine::e_net_dormancy::e_net_dormancy_initial );
            local_pawn->b_always_relevant( true );
            local_pawn->b_replicates( true );
            local_pawn->b_replicate_movement( true );

            if ( auto movement = local_pawn->character_movement( ) ) {
                save_movement_state( movement );

                movement->set_is_replicated( true );
            }

            m_is_enabled = true;
        }

        void disable( engine::a_pawn* local_pawn ) {
            if ( !local_pawn || !m_is_enabled )
                return;

            if ( auto movement = local_pawn->character_movement( ) ) {
                movement->max_walk_speed( m_original_movement_state.original_walk_speed );
                movement->max_fly_speed( m_original_movement_state.original_fly_speed );
                movement->max_custom_movement_speed( m_original_movement_state.original_custom_speed );
                movement->gravity_scale( m_original_movement_state.original_gravity );
                movement->max_acceleration( m_original_movement_state.original_acceleration );
                movement->braking_friction_factor( m_original_movement_state.original_friction_factor );
                movement->ground_friction( m_original_movement_state.original_ground_friction );
                movement->jump_z_velocity( m_original_movement_state.original_jump_velocity );
                movement->jump_off_jump_z_factor( m_original_movement_state.original_jump_factor );
                movement->air_control( m_original_movement_state.original_air_control );
                movement->air_control_boost_multiplier( m_original_movement_state.original_air_boost );
                movement->falling_lateral_friction( m_original_movement_state.original_lateral_friction );
                movement->b_orient_rotation_to_movement( m_original_movement_state.original_rotation_to_movement );
                movement->max_step_height( m_original_movement_state.original_max_step_height );
                movement->b_movement_in_progress( m_original_movement_state.original_movement_in_progress );
                movement->b_enable_physics_interaction( m_original_movement_state.original_enable_physics_interaction );
                movement->buoyancy( m_original_movement_state.original_buoyancy );

                movement->set_movement_mode( m_original_movement_state.original_movement_mode );

                movement->b_ignore_client_movement_error_checks_and_correction( false );
                movement->b_server_accept_client_authoritative_position( false );
                movement->b_force_max_accel( false );
                movement->b_run_physics_with_no_controller( false );
                movement->b_always_check_floor( false );
                movement->network_smoothing_mode( 1 );
                movement->b_network_update_received( false );

                movement->b_maintain_horizontal_ground_velocity( false );
                movement->b_requested_move_use_acceleration( false );
                movement->analog_input_modifier( 0.f );

                movement->set_is_replicated( false );
            }

            local_pawn->role( m_original_pawn_state.original_role );
            local_pawn->remote_role( m_original_pawn_state.original_remote_role );
            local_pawn->net_dormancy( m_original_pawn_state.original_dormancy );
            local_pawn->b_always_relevant( m_original_pawn_state.original_always_relevant );
            local_pawn->b_replicates( m_original_pawn_state.original_replicates );
            local_pawn->b_replicate_movement( m_original_pawn_state.original_replicate_movement );

            m_is_enabled = false;
        }

        bool is_enabled( ) const {
            return m_is_enabled;
        }

        bool is_flying( ) const {
            return m_is_flying;
        }

    private:
        void save_pawn_state( engine::a_pawn* pawn ) {
            m_original_pawn_state.original_role = pawn->role( );
            m_original_pawn_state.original_remote_role = pawn->remote_role( );
            m_original_pawn_state.original_dormancy = pawn->net_dormancy( );
            m_original_pawn_state.original_always_relevant = pawn->b_always_relevant( );
            m_original_pawn_state.original_replicates = pawn->b_replicates( );
            m_original_pawn_state.original_replicate_movement = pawn->b_replicate_movement( );
        }

        void save_movement_state( engine::u_character_movement_component* movement ) {
            m_original_movement_state.original_walk_speed = movement->max_walk_speed( );
            m_original_movement_state.original_fly_speed = movement->max_fly_speed( );
            m_original_movement_state.original_custom_speed = movement->max_custom_movement_speed( );
            m_original_movement_state.original_gravity = movement->gravity_scale( );
            m_original_movement_state.original_acceleration = movement->max_acceleration( );
            m_original_movement_state.original_friction_factor = movement->braking_friction_factor( );
            m_original_movement_state.original_ground_friction = movement->ground_friction( );
            m_original_movement_state.original_jump_velocity = movement->jump_z_velocity( );
            m_original_movement_state.original_jump_factor = movement->jump_off_jump_z_factor( );
            m_original_movement_state.original_air_control = movement->air_control( );
            m_original_movement_state.original_air_boost = movement->air_control_boost_multiplier( );
            m_original_movement_state.original_lateral_friction = movement->falling_lateral_friction( );
            m_original_movement_state.original_rotation_to_movement = movement->b_orient_rotation_to_movement( );
            m_original_movement_state.original_movement_mode = movement->movement_mode( );
            m_original_movement_state.original_max_step_height = movement->max_step_height( );
            m_original_movement_state.original_movement_in_progress = movement->b_movement_in_progress( );
            m_original_movement_state.original_enable_physics_interaction = movement->b_enable_physics_interaction( );
            m_original_movement_state.original_buoyancy = movement->buoyancy( );
        }

    private:
        bool m_is_enabled = false;
        bool m_is_flying = false;
        movement_state m_original_movement_state{};
        pawn_state m_original_pawn_state{};
    };
}