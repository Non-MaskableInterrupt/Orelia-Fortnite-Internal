#pragma once

namespace exploits {
    class c_chams {
    public:
        bool apply( engine::a_fort_player_pawn_athena* player ) {
            if ( !features::exploits::enabled )
                return false;

            if ( !init_material( features::exploits::chams_material ) )
                return false;

            if ( features::exploits::chams ) {
                update_properties( );
                store_materials( player );
                apply_materials( player );
                m_applied_material = true;
            }
            else if ( m_applied_material ) {
                if ( restore( player ) )
                    m_applied_material = false;
            }

            return true;
        }

        bool apply( engine::a_fort_weapon* weapon ) {
            if ( !features::exploits::enabled )
                return false;

            if ( !init_material( features::exploits::chams_material ) )
                return false;

            if ( features::exploits::weapon_chams ) {
                update_properties( );
                store_materials( weapon );
                apply_materials( weapon );
                m_weapon_applied_material = true;
            }
            else if ( m_weapon_applied_material ) {
                if ( restore( weapon ) )
                    m_weapon_applied_material = false;
            }

            return true;
        }

        bool apply_crown_win( engine::a_fort_player_pawn_athena* player ) {
            if ( !features::exploits::enabled )
                return false;

            if ( !features::exploits::crown_win )
                return false;

            if ( !init_crown_materials( ) )
                return false;

            store_materials( player );
            apply_crown_materials( player );
            m_crown_applied = true;

            return true;
        }

        void apply_stencil( engine::u_mesh_component* mesh ) {
            mesh->set_custom_depth_stencil_value( 11 );
            mesh->set_render_custom_depth( true );
            mesh->set_render_in_main_pass( true );
        }

    private:
        bool init_material( int material_index ) {
            if ( m_material_index_applied == material_index )
                return true;

            static const wchar_t* material_paths[ ] = {
                L"/Game/Effects/Niagara/MasterMaterials/Ribbon/M_Ribbon_Master_v3.M_Ribbon_Master_v3",
                L"/Game/Packages/Fortnite_UniqueMaterials_1/Effects/CharacterShield_DimMak.CharacterShield_DimMak",
                L"/Game/Effects/Fort_Effects/Effects/Characters/Generic/ResIn/RezIn_Master.RezIn_Master",
                L"/Game/Characters/Player/Common/SharedMaterials/M_MED_Glass_WithDiffuse.M_MED_Glass_WithDiffuse",
                L"/Game/Characters/Player/Male/Medium/Heads/M_MED_AUX_Alien_Head_01/Materials/M_AMR_Glass_FishBowl.M_AMR_Glass_FishBowl"
            };

            if ( material_index >= 0 && material_index < std::size( material_paths ) ) {
                m_material = engine::u_object::find_object<engine::u_material*>(
                    material_paths[ material_index ]
                );
            }

            if ( !m_material )
                return false;

            m_material->blend_mode( engine::e_blend_mode::additive );
            m_material_index_applied = material_index;
            return true;
        }

        void store_materials( engine::a_fort_player_pawn_athena* player ) {
            if ( !player )
                return;

            auto skeletal_meshes = player->skeletal_meshes( );
            for ( int mesh_idx = 0; mesh_idx < skeletal_meshes.size( ); mesh_idx++ ) {
                auto mesh = skeletal_meshes[ mesh_idx ];
                if ( !mesh || m_backups.find( mesh ) != m_backups.end( ) )
                    return;

                auto mats = mesh->get_materials( );
                std::vector<std::pair<int32_t, engine::u_material_interface*>> backups;

                for ( int32_t mat_idx = 0; mat_idx < mats.size( ); mat_idx++ ) {
                    if ( auto orig = mesh->get_material( mat_idx ) ) {
                        backups.push_back( { mat_idx, orig } );
                    }
                }

                if ( !backups.empty( ) )
                    m_backups[ mesh ] = backups;
            }
        }

        void store_materials( engine::a_fort_weapon* weapon ) {
            if ( !weapon )
                return;

            auto weapon_meshes = weapon->all_weapon_meshes( );
            for ( int mesh_idx = 0; mesh_idx < weapon_meshes.size( ); mesh_idx++ ) {
                auto mesh = weapon_meshes[ mesh_idx ];
                if ( !mesh || m_weapon_backups.find( mesh ) != m_weapon_backups.end( ) )
                    return;

                auto mats = mesh->get_materials( );
                std::vector<std::pair<int32_t, engine::u_material_interface*>> backups;

                for ( int32_t mat_idx = 0; mat_idx < mats.size( ); mat_idx++ ) {
                    if ( auto orig = mesh->get_material( mat_idx ) ) {
                        backups.push_back( { mat_idx, orig } );
                    }
                }

                if ( !backups.empty( ) )
                    m_weapon_backups[ mesh ] = backups;
            }
        }

        void update_properties( ) {
            if ( !m_material )
                return;

            if ( features::exploits::wireframe )
                m_material->wireframe( true );
            else
                m_material->reset_wireframe( true );

            if ( features::exploits::xray_chams )
                m_material->b_disable_depth_test( true );
            else
                m_material->reset_b_disable_depth_test( true );

            m_material->two_sided( true );
            m_material->b_use_emissive_for_dynamic_area_lighting( true );
        }

        void apply_parameters(
            engine::u_material_instance_dynamic* instance,
            engine::flinear_color color
        ) {
            static const std::vector<std::vector<const wchar_t*>> material_params = {
                { // M_Ribbon_Master_v3
                    L"Color A",
                    L"Color B",
                    L"Leading Gradient Color",
                    L"Trailing Gradient Color"
                },
                { // CharacterShield_DimMak
                    L"S Color1",
                    L"S Color2",
                    L"Offset Vector"
                },
                { // RezIn_Master (index 2)
                    L"WireFrameFadeOffColor",
                    L"WireFrameParameterHighlight",
                    L"DissolveGradientDirectionalVector",
                    L"DissolveGradientBaseLocation",
                    L"DissolveSphericalGradientHandLocationAndRadius",
                    L"AverageHandPosition",
                    L"EmissiveMultiplier",
                    L"colcol1",
                    L"colcol2",
                    L"WorldPostionOfBlackHole",
                    L"offset",
                    L"Top Color",
                    L"Bottom Color"
                },
                { // M_MED_Glass_WithDiffuse
                    L"Glass Color",
                    L"Fresnel Color",
                    L"Reflection Color"
                },
                { // M_AMR_Glass_FishBowl
                    L"Base Color",
                    L"Normal Intensity",
                    L"Cube Map Multiplier",
                    L"BubbleReflection",
                    L"waterColor",
                    L"DissolveGradientDirectionalVector",
                    L"DissolveGradientBaseLocation",
                    L"DissolveSphericalGradientHandLocationAndRadius"
                }
            };

            static const std::vector<std::vector<const wchar_t*>> scalar_params = {
                // ... other materials ...
                { // M_MED_Glass_WithDiffuse (index 3)
                    L"EmissiveMult",
                    L"Specular",
                    L"Spec Intense",
                    L"Spec Highlight Power",
                    L"Fresnel Inner Transparency",
                    L"Fresnel Outer Transparency",
                    L"Fresnel Exponent",
                    L"Metallic",
                    L"Roughness",
                    L"Refraction",
                    L"Cosmetic Emissive EyeAdaptation Alpha"
                }
            };

            static const std::vector<std::vector<float>> scalar_values = {
                // ... other materials ...
                { // M_MED_Glass_WithDiffuse (index 3)
                    5.0f,  // EmissiveMult
                    3.0f,  // Specular
                    3.0f,  // Spec Intense
                    4.0f,  // Spec Highlight Power
                    0.2f,  // Fresnel Inner Transparency
                    0.85f, // Fresnel Outer Transparency
                    1.0f,  // Fresnel Exponent
                    0.1f,  // Metallic
                    0.1f,  // Roughness
                    1.0f,  // Refraction
                    1.0f   // Cosmetic Emissive EyeAdaptation Alpha
                }
            };

            if ( m_material_index_applied < material_params.size( ) ) {
                for ( const auto& param : material_params[ m_material_index_applied ] ) {
                    instance->set_vector_parameter_value(
                        engine::kismet::g_string_library->conv_string_to_name( param ),
                        color
                    );
                }
            }
        }

        void apply_materials( engine::a_fort_player_pawn_athena* player ) {
            if ( !player || !m_material )
                return;

            auto skeletal_meshes = player->skeletal_meshes( );
            for ( int i = 0; i < skeletal_meshes.size( ); i++ ) {
                apply_mesh_materials( skeletal_meshes[ i ], features::exploits::chams_color );
            }
        }

        void apply_materials( engine::a_fort_weapon* weapon ) {
            if ( !weapon || !m_material )
                return;

            auto weapon_meshes = weapon->all_weapon_meshes( );
            for ( int i = 0; i < weapon_meshes.size( ); i++ ) {
                apply_mesh_materials( weapon_meshes[ i ], features::exploits::weapon_color );
            }
        }

        void apply_mesh_materials( engine::u_mesh_component* mesh, const engine::flinear_color& color ) {
            if ( !mesh )
                return;

            auto mats = mesh->get_materials( );
            for ( auto xi = 0; xi < mats.size( ); xi++ ) {
                if ( auto inst = mesh->create_dynamic_material_instance( xi, m_material, engine::fname( ) ) ) {
                    apply_parameters( inst, color );
                    mesh->set_material( xi, inst );
                }
            }
        }

        bool restore( engine::a_fort_player_pawn_athena* player ) {
            if ( !player )
                return false;

            auto meshes = player->skeletal_meshes( );
            for ( auto i = 0; i < meshes.size( ); i++ ) {
                auto mesh = meshes[ i ];
                if ( !mesh )
                    continue;

                auto it = m_backups.find( mesh );
                if ( it == m_backups.end( ) )
                    continue;

                for ( auto& [idx, mat] : it->second ) {
                    if ( auto new_inst = mesh->create_dynamic_material_instance( idx, mat, engine::fname( ) ) ) {
                        auto mat_inst = static_cast< engine::u_material_instance* >( mat );
                        if ( mat_inst )
                            new_inst->copy_parameter_overrides( mat_inst );

                        mesh->set_material( idx, new_inst );
                    }
                }

                m_backups.erase( it );
            }

            return m_backups.empty( );
        }

        bool restore( engine::a_fort_weapon* weapon ) {
            if ( !weapon )
                return false;

            auto meshes = weapon->all_weapon_meshes( );
            for ( auto i = 0; i < meshes.size( ); i++ ) {
                auto mesh = meshes[ i ];
                if ( !mesh )
                    continue;

                auto it = m_weapon_backups.find( mesh );
                if ( it == m_weapon_backups.end( ) )
                    continue;

                for ( auto& [idx, mat] : it->second ) {
                    if ( auto new_inst = mesh->create_dynamic_material_instance( idx, mat, engine::fname( ) ) ) {
                        auto mat_inst = static_cast< engine::u_material_instance* >( mat );
                        if ( mat_inst )
                            new_inst->copy_parameter_overrides( mat_inst );

                        mesh->set_material( idx, new_inst );
                    }
                }

                m_weapon_backups.erase( it );
            }

            return m_weapon_backups.empty( );
        }

    public:
        bool init_crown_materials( ) {
            if ( !m_crown_beams ) {
                m_crown_beams = engine::u_object::find_object<engine::u_material*>(
                    L"/VictoryCrownsGameplay/UI/Materials/M_UI_CrownBeams.M_UI_CrownBeams"
                );
            }

            return m_crown_beams;
        }

        void apply_parameters(
            engine::u_material_instance_dynamic* beams_inst
        ) {
            if ( !beams_inst )
                return;

            beams_inst->set_scalar_parameter_value(
                engine::kismet::g_string_library->conv_string_to_name( L"Alpha" ), 0.5f );
            beams_inst->set_vector_parameter_value(
                engine::kismet::g_string_library->conv_string_to_name( L"Color" ),
                engine::flinear_color( 1.0f, 0.916667f, 0.5f, 1.0f ) );
            beams_inst->set_vector_parameter_value(
                engine::kismet::g_string_library->conv_string_to_name( L"FalloffColor" ),
                engine::flinear_color( 1.0f, 0.666667f, 0.0f, 1.0f ) );
        }

        void apply_crown_materials( engine::a_fort_player_pawn_athena* player ) {
            if ( !player || !m_crown_beams )
                return;

            auto skeletal_meshes = player->skeletal_meshes( );
            for ( int i = 0; i < skeletal_meshes.size( ); i++ ) {
                auto mesh = skeletal_meshes[ i ];
                if ( !mesh ) continue;
                
                auto mats = mesh->get_materials( );
                for ( auto xi = 0; xi < mats.size( ); xi++ ) {
                    auto beams_inst = mesh->create_dynamic_material_instance( xi, m_crown_beams, engine::fname( ) );
                    if ( !beams_inst ) continue;
                    apply_parameters( beams_inst );

                    mesh->set_material( xi, beams_inst );
                }
            }
        }

    private:
        engine::u_material* m_material = nullptr;
        std::unordered_map<
            engine::u_mesh_component*,
            std::vector<std::pair<int32_t, engine::u_material_interface*>>
        > m_backups;

        std::unordered_map<
            engine::u_mesh_component*,
            std::vector<std::pair<int32_t, engine::u_material_interface*>>
        > m_weapon_backups;

        engine::u_material* m_crown_beams = nullptr;
        bool m_crown_applied = false;

        int m_material_index_applied = INT_MAX;
        bool m_applied_material = false;
        bool m_weapon_applied_material = false;
    };
}